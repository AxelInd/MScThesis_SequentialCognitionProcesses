# -*- coding: utf-8 -*-
"""
Created on Tue Jan 21 12:14:20 2020

@author: Axel

This file provides two different search mechanisms for SCPs in the context of the suppression task
1) de novo search from the initially provided rules to meet a specified variable assignment goal
2) modifying (without removing): inserting complex operations into an existing SCP to go from modelling a general to an individual reasoner
"""
import scp
import copy
import basicLogic
#STARTING VARIABLES
# e: she has an essay to write
e = basicLogic.atom('e', setValue=False)
# l: she will study late in the library
l = basicLogic.atom('l', setValue=False)
# o: the library is open
o = basicLogic.atom('o', setValue=False)

#STARTING RULES, FACTS
# if she has an essay to write, she will study late in the library
knowledge1 = basicLogic.operator_bitonic_implication(e,l)
# she has an essay to write
knowledge2 = basicLogic.operator_bitonic_implication(basicLogic.TRUE_noValue, e)
# if the library is open, she will study late in the library
knowledge3 = basicLogic.operator_bitonic_implication(o, l)
# the lirary is open
knowledge4 = basicLogic.operator_bitonic_implication(basicLogic.TRUE_noValue, o)

#INITIALISE THE SET OF COMPLEX OPERATORS M

# create the initial state of the SCP
comp_initialise = scp.complexOperation_init ()
# create the complex operation to add abnormalities
comp_addAB = scp.complexOperation_addAB ()
# create the complex operation to delete a named variable
comp_deleteo = scp.complexOperation_deleteVariable('o')
# create the complex operation to fix a named variable to a specified value
comp_fixab1 = scp.complexOperation_fixVariable('ab1', False)
# Create the complex operation to weakly complete the logic program
comp_weak = scp.complexOperation_weaklyComplete()
# create the complex operation to apply the sematic operator
comp_semantic = scp.complexOperation_semanticOperator()

# =============================== SEARCH ===========================================
M = []
# create the list containing all comple operations which should be considered during search.
# the paper @TODO describes the procedure and best practices for choosing these.
# note that comp_initialise is exluded from this list, as the de-facto start variable, it is only used once in an SCP.
M.append(comp_addAB)
M.append(comp_deleteo) 
M.append(comp_fixab1)
M.append(comp_semantic)
M.append(comp_weak)
# The maximum search depth of the algorithm for either search type
LIMIT = 5
#==============================================================================
#================================DE NOVO SEARCH================================
#==============================================================================
"""
THIS IS A BASIC BREADTH-FIRST SEARCH IMPLEMNTATION FOR A VARIABLE ASSIGNMENT
@param p: the empty scp, containing the variables and rules of the problem (as present in state s_0)
@param iteration: the depth to which the bfs has already searched
@param solutions: a list of the scps which, when evaluated to the final state, satisfy the goal conditions
@param goalV: the set of variable assignments which constitute a success, in the form (string:variableName,bool:truthValue=True/False/None)
@param limit: the maximum search depth for the bfs
@param goalKB: the rules which should be present in the final epistemic state (@TODO not yet implemented)
"""
def scpDeNovoSearch (p, iteration, solutions = [], goalV = None, limit = LIMIT, goalKB = None):
    # the final epistemic state of the agent after the SCP is run
    kb = p.evaluateKB()
    # the final epistemic variable assignments of the agent after the SCP is run
    v = p.evaluateV()
    # check goal condition
    # at present goals are limitted to variable assignments @TODO extend
    # duplicate solutions are removed
    for var in v:
        if var.name == goalV[0] and var.value==goalV[1]:
            solutions = solutions + [p]
            return list(dict.fromkeys(solutions))
    # check that maximum search depth has not yet been reached
    # returns an empty list if it has
    if iteration + 1 >= limit:
        return []
    # create an scp that is the current scp + m, where m is complex operation in M
    # deepcopy ensures that the scp pointers to objects are not shared
    # repeats the search using the newscps
    for m in p.M:
        scpTemp = copy.deepcopy(p)
        scpTemp.addNext(m)
        result  = scpDeNovoSearch(scpTemp, iteration+1, solutions, goalV, limit, goalKB)
        solutions = solutions  + result
    # returns the list of all solutions found thus far
    # duplicate solutions are removed
    return list(dict.fromkeys(solutions))

"""
GET A PRINTABLE STRING DESCRIBING EACH SOLUTION ON A NEW LINE
@param li: The list of solutions generated by either scpDeNovoSearch(...) or @TODO
@return a string detailing each scp in li on a new line
"""    
def strSCPList (li):
    s = (">" * 15) + "SOLUTIONS"+("<"*15) +"\n"
    for sc in li:
        s = s + str(sc) + "\n"
    s=s+"-------------------------"
    return s
        
#==============================================================================
#=============================MODIFICATION SEARCH==============================
#==============================================================================
"""
INSERT A COMPLEX OPERATION INTO AN SCP AT A SPECIFIED POSITION
@param m: a complex operation
@param _scp: the SCP into which m must be insterted
@param pos: the position in the scp into which m must be insterted
"""
def insert(m,_scp, pos):
    newscp=copy.deepcopy(_scp)
    newscp.insertAtPos(m,pos)
    return newscp
"""
REMOVE A SINGLE COMPLEX OPERATION FROM A LIST OF COMPLEX OPERATIONS
@param m: the complex operation to be removed (passed by reference)
@param M: the list of complex operations from which m should be removed
@return the set of complex operations M without the complex operation m ([] if all m in M are deleted)
"""
def remove (m,M):
    alreadyRemoved=False
    # the empty list that will contain all m' in M except for m
    newM = []
    # append an operation i in M to newM iff m isn't the complex operation that must be deleted
    for i in M:
        if i != m:
            newM.append(i)
        elif alreadyRemoved == False:
            alreadyRemoved=True
            print ("A dup")
    return newM

"""
DETERMINE ALL SCPS THAT CAN BE MADE BY INSERTING M' INTO THE ORGINAL SCP, AND RETURN THOSE THAT SATISFY THE GOAL CONDITION
@param M': the subset of actions in M which must be inserted into the scp
@param _scp: the SCP to be evaluated or extended to meet the new goal criteria
@param goalV: the set of variable assignments which constitute a success, in the form (string:variableName,bool:truthValue=True/False/None)
@return returns a list of all scps which ,when the complex operation M' are inserted in the original scp, satisfy the goal
"""
def randomisedInsert (Mprime,_scp, goalV, solutions):
    # if M' is the empty set, check if the current scp, when evluated, leads to variable assignments that satisfy the goal
    # if the final epistemic state satisfies the goal, return the scp, else return the empty set
    if len(Mprime)==0:
        v = _scp.evaluateV()
        for var in v:
            if var.name == goalV[0] and var.value == goalV[1]:
                return [_scp]
        return []
    # combination(...) already generates every possible combination, so we are only concerned with inserting them
    # we insert the first m in every position in the scp, then we remove that m from Mprime and repreat the process with the shortened list
    # we ignore position 0 as this is the init operation in the SCP
    for pos in range (1, len(_scp)):      
        # insert the first m in M' into the position pos
        newscp = insert(Mprime[0],_scp, pos)
        # remove the first complex operation in M' from the list
        newMprime = remove(Mprime[0],Mprime)
        # repeat this operation using the extended SCP and the shortened M'
        insertAndEvaluate = randomisedInsert(Mprime=newMprime,_scp=newscp, goalV=goalV, solutions=solutions)
        # add any solutions that can use this scp as a base and then add some m in newM' to it to satisfy the goal
        solutions = solutions + insertAndEvaluate
    #return the solutions without any duplicates
    return list(dict.fromkeys(solutions))
"""
FINDS THE LIST OF ALL SCPS WHICH CAN BE MADE BY ADDING depth NUMBER OF OPERATIONS FROM M (ALLOWING REPEATS) TO EXISTING SCP _scp.
_scp IS ASSUMED INITIALLY TO BE A WELL FOUNDED SCP THAT DESCRIBES A GENERAL PHENOMENON IN SUBJECTS. USING THIS SEARCH EXTENSIONS
TO _scp CAN BE FOUND WHICH NOW MODEL OTHER REASONER CASES BUT STILL ASSUME THAT THEY ARE FOUNDED ON THE ORIGINAL SCP. 
Note: this is a fairly intensive search procedure and search depths > 3 are very computationally slow, use with care.
@param M': the subset of actions in M which must be inserted into the scp
@param M: the list of allowable complex actions
@param depth: the maximum number of complex operations to instert into the scp
@param _scp: the SCP which represents the general case of the porblem we are trying solve for the individual case
@param goalV: the set of variable assignments which constitute a success, in the form (string:variableName,bool:truthValue=True/False/None)
@param solutions: the set of scps which, when evaluated, satsify the goal conditions (before the new action is added on this iteration)
@return a list of all scps which when evaluated, satisfy the goal conditions (after the new action is added on this iteration)
"""
def scpCombinationSearch (Mprime, depth, _scp, goalV, solutions=[]):
    # copy the scp so that pointers are not shared
    _scp =copy.deepcopy(_scp)
    # randomly inserts all m in M' into the initial
    solutions = randomisedInsert(Mprime, _scp, goalV, solutions=solutions)
    # return all solutions if maximum search depth is reached
    if depth==0: 
        return solutions
    # repeat this method, extending Mprime with the complex action m
    for m in _scp.M:    
        solutions= scpCombinationSearch(Mprime+[m], depth-1, _scp, goalV, solutions)
    return list(dict.fromkeys(solutions))
        
#==============================================================================
#==================================TESTING=====================================
#==============================================================================
"""
USE THE DE NOVO SEARCH TO FIND ALL SOLUTIONS WHICH SATISFY THE GOAL VARIABLES
@param goalV: the set of variable assignments which constitute a success, in the form (string:variableName,bool:truthValue=True/False/None)
@param limit: the maximum search depth for the bfs
"""
def testDeNovoSearch (goalV, limit=LIMIT ):
    # the empty scp which will be used to find the solutions
    p = scp.scp()   
    # add the list of allowable complex operations to the SCP
    p.addM(M)
    # add the known rules
    p.addKnowledge(knowledge1)
    p.addKnowledge(knowledge2)
    p.addKnowledge(knowledge3)
    # add the known variables
    p.addVariable(e)
    p.addVariable(l)
    p.addVariable(o)
    # add the initialise complex operation
    p.setState1(comp_initialise)
    # add any other complex operations guaranteed to be performed next by p
    #p.addNext(comp_addAB)
    #p.addNext(comp_weak)
    
    # get a list of all possible successive SCPs which meet the given goal conditions
    results = scpDeNovoSearch(p, iteration=0, goalV=goalV, limit=LIMIT)   
    # print all the solutions found
    print(strSCPList(results))    
"""
USE THE MODIFIED BFS SEARCH TO INSERT limit NUMBER OF NEW OPERATION INTO AND EXISTING SCP IN ORDER TO
FIND ALL EXTENSIONS WHICH SATISFY SOME GOAL CONDITION
@param goalV: the set of variable assignments which constitute a success, in the form (string:variableName,bool:truthValue=True/False/None)
@param limit: the number of complex operations to be added to the SCP
"""
def testModificationSearch(goalV, limit=LIMIT):
    q = scp.scp()   
    
    q.addM(M)
    
    q.addKnowledge(knowledge1)
    q.addKnowledge(knowledge2)
    q.addKnowledge(knowledge3)
    
    q.addVariable(e)
    q.addVariable(l)
    q.addVariable(o)
    
    q.setState1(comp_initialise)
    #p.addNext(comp_addAB)
    q.addNext(comp_addAB)
    q.addNext(comp_weak)
    q.addNext(comp_semantic)
    q.addNext(comp_semantic)
    q.addNext(comp_semantic)

    solutions = scpCombinationSearch(Mprime=[], depth=limit, _scp=q, goalV=goalV)
    print ("Number of solutions found: " + str(len(solutions)))
    #print (strSCPList(solutions))
    print ("The initial SCP was:")
    print(q)


# use this method to test a general BFS search algorithm that finds a set of SCPs that model the suppression task
testDeNovoSearch(goalV=('l',True), limit=5)
# Use this method to test a modified BFS algorithm that finds possible extensions of an existing SCP that satisfy a goal
testModificationSearch(goalV=('l',True), limit=2)




































